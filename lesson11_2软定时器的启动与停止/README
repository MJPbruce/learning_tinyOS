
RTOS知识点简要概括

3.1 临界区保护
1、为什么需要临界区保护

临界区保护的目的是为了防止共享资源（包括全局变量等）被同时访问。比如任务1正在进行一个count++的操作，此时调度系统强行切换到任务2运行，任务2中也有count++的操作，那么
我们的count++操作就没有按照我们的设计目的来完成，就会出现原来的修改值被覆盖的问题。或者我们在一个任务中使用count++操作时发生了一个中断，在中断服务程序中操作count也会
出现同样的问题，所以，就需要引入临界区保护的措施。

2、怎么进行临界区的保护

先搞清楚发生共享资源访问冲突的两个种情况：1、任务切换时会发生访问冲突。2、中断发生时会发生访问冲突。
我们知道任务切换时是在PendSV中断中完成的，其本质也是发生了中断，那么在访问一些可能引发冲突的变量时，我们可以暂时关闭所有可屏蔽中断，这样就可以解决资源访问冲突的
问题。

3、这样操作有何缺点

1、关闭可屏蔽中断，使得系统的实时响应变差。
2、关闭可屏蔽中断，系统不能进行任务切换调度，只能执行当前任务中的代码，使得系统实时性变差。


3.2 调度锁保护

1、问什么需要调度锁的保护

1.1 为了解决临界区保护屏蔽所有中断使得系统实时性变差的问题
1.2 有些共享资源访问冲突只是在任务切换中体现，不设计中断中使用，此时我们应该让中断响应正常执行。

2、什么是调度锁保护

调度锁保护顾名思义就是上了调度锁后，调度系统暂时失效，必须要等当前任务被保护部分执行完毕解锁后才能继续进行任务调度。

3、怎么实现调度锁保护

调度锁保护的实现机制很简单，我们定义一个全局变量，当需要使用调度锁的时候，让该全局变量+1，然后再调度函数中判断该全局变量是否为0，如果为0，说明所有的调度锁都已
解锁，那么我们就执行调度算法，如果不为0，那么就有任务上锁了，直接退出。
注意：上锁资源中尽量不要出现延时函数，否则会影响延时效果。


FCARM - Output Name not specified, please check 'Options for Target - Utilities'
错误原因：引入了不知名的文件类型，需要查看文件属性来解决。


3.3 位图

引入位图的概念是为了引入优先级的概念


3.5 双向链表

引入双向链表是为了管理各种数据结构，也是为了方便扩展

3.6 延时队列的实现

之前的延时，实现的方式都是循环扫描各个task的delayTicks，如果delayTicks==0 那么就将该任务就绪，这样操作有一个缺点就是太耗时，taskTable中的有些task我们并没有定义
但是在扫描的时候我们还是扫描了delayTicks 这么操作就使得多做了一些无用功，需要优化。

我们优化的方式就是加入延时队列，将需要延时等待的任务加入到延时队列中来，将不需要延时等待的任务不加入。那么在systick中断中，我们只需要扫描对应的延时任务就行了。

3.7 相同优先级时间片轮流运行

我们之前提到的任务管理方式是使用tTask * taskTable[];来管理的，这种管理方式下，每个优先级只能有一个任务来运行。那么我们想让两个任务占用相同的优先级该怎么办呢？
方法和实现延时队列一样，使用list来管理taskTable，这样我们可以在这个任务队列中加入很多子任务。

4.1 任务的挂起和恢复

我们上节课已经将任务加入到任务队列中中去了，任务的挂起就是将该任务从任务队列中删除，任务恢复就是将该任务从任务队列中恢复。

本节内容还会将代码结构做一下调整，将对应的模块放在对应的文件中，这样后续的代码更好管理。


4.2 任务的删除

任务删除的关键是释放掉该任务所占用的资源。

有两种任务的删除操作：1) 别的任务强制删除其他任务。 2) 别的任务请求删除其他任务，其他任务检测到自己要被删除时，在调用删除自己任务的接口。

4.3 获取任务状态信息

我们定义了一个专门获取任务状态信息的函数，需要获取什么信息可以在task_info结构体中直接添加，调用也比较简单。

5.1 事件控制块

事件控制块有什么作用呢？ 可以进行事件的同步 事件之间的通讯等等
事件控制块的实现是使用一个结构体将需要等待的事件和等待队列封装在一起，比如我们要实现任务的同步运行，可以将一个信号量封装成一个任务控制块，然后把需要同步的任务放在
等待队列中，当信号量清0时，等待队列中的任务就加入到就绪队列中去，这样就可以实现任务的同步了。同理还可以采集中断，置中断标志位来实现特定的任务的运行。

5.2 事件的等待与通知

我们需要在任务的结构体中加入等待事件的相关字段，当把等待事件加入到等待列表中时，我们需要把任务的等待相关字段设置，当把任务从等待列表中移除时，同样也需要配置任务
的等待相关字段，这样我们获取任务信息时，就可以得到该任务等待相关的字段。也就知道了任务是被什么唤醒的等等。

5.3 事件控制块的清空与状态查询

清空事件控制块列表就是将事件控制列表中的所有节点都释放掉，只需一个函数完成就行。

6.1 信号量的原理与创建

信号量的组成包括事件控制块和计数器，我们可以用信号量来实现资源的访问和任务同步等。本节主要完成了信号量的创建和初始化任务。

6.2 计数信号量的获取与释放

计数信号量可以看成是阻塞的，我们在当前任务中等待一个信号量时，如果这个信号量没有等到，我们就阻塞当前任务，然后切换到其他任务去运行。
如果其他任务通知了这个信号量，那么我们再将阻塞的任务从信号量列表中释放出来，加入到调度任务中去，这样就完成了信号量的获取和释放。

7.1 邮箱结构体的定义和初始化

我们使用邮箱来在各个任务之间传递信息，邮箱里面应该有一个任务控制块用来实现当任务没有获取到想要的信息且加入到等待队列中去，然后定义一个环形的数据缓冲区，
包括读索引、写索引、数据缓冲区的地址以及最大信息量和当前信息量等字段。

7.2 邮箱的等待和通知

我们使用邮箱的目的是为了在各个任务之间传递信息，其用法不同于信号量的是，我们在等待的时候，会等待一个信息出来。

7.3 邮箱的清空和销毁

邮箱清空就是将邮箱的信息字段全部清空，邮箱的销毁就是将邮箱中的等待队列全部移除，加入到调度列表中。

7.4 邮箱状态信息查询

定义一个状态信息结构体，然后将需要获取的邮箱状态拷贝出来就行了。

8.1 存储块的原理与创建

我们知道C库函数中有malloc和free两个函数专门用来内存的申请和创建的函数，但是在RTOS中，我们不希望这么做。因为RTOS运行的硬件环境中没有很多的RAM资源供我们管理，其次
malloc和free的RAM申请与释放本身就占用比较多的系统资源。我们采用另外一种方式来对内存进行申请和释放，那就是存储块。

存储块的原理是：我先划分固定大小的存储空间，然后将存储空间加入到存储队列中去，当有任务向我这里申请存储空间时，我就给它一个，当存储空间用完时，任务就进入等待
队列，当有新的存储块释放时，就让任务重新获取该存储队列并加入到任务调度系统。

8.2 存储控制块的获取和释放

获取存储块就是取得存储块中内存首地址，当没有存储块可用时，我们会将试图获取存储块的任务加入到等待队列中去，如果有可用存储块，则从存储控制块的首地址取出存储块给
任务使用。

释放存储块的原理是：如果有正在等待的任务，那我们就将该存储块给正在等待的任务并将其唤醒，如果没有正在等待的任务，我们将此存储块插入到存储控制块列表的末尾。

8.3 存储块的信息查询和销毁

存储块的信息查询实现的原理是：定义一个存储块的信息结构体，然后再具体的函数体中拷贝一份我们需要查询的存储块的信息就OK了。
存储块的销毁实现的原理是：释放所有正在等待存储块的任务，然后执行一次调度即可。因为我们的存储块都是定义的全局变量数组，释放的时候也不可能删除全局变量
只能将存储块等待列表释放并加入到任务调度列表中去。

9.1 事件标志组的原理和创建

事件标志组就是用位图的数据结构来定义一系列的事件标志，事件标志组应当包含一个任务控制块和一个事件标志数据结构，我们为了简单 定义了一个uint32_t的事件标志 可以
最大接受32个事件标志。

9.2 事件标志组的等待与通知

事件标志组的等待就是当前任务等待特定的事件是否发生，如果发生我们直接继续执行，如果没有发生，则加入到等待队列中去，直到需要等待的事件发生。
事件标志组的通知就是通知这个事件标志组有特定的事件发生了（清0或置1），如果等待队列中有等待任务，则遍历等待事件，然后看是否和等待任务的标志匹配，如果匹配则
直接将此任务从等待列表中唤醒。

9.3 事件标志组的删除与查询

事件标志组的删除就是将当前等待的所有任务加入到任务就绪列表中去
事件标志组的查询就是获取当前事件标志组的flags和等待队列中的任务数量

10.1 互斥信号量的原理和创建

我们已经有一个计数信号量了，为什么还需要互斥信号量呢？ 举个例子：我们知道计数信号量可以用来访问有限的硬件资源，我们可以在其他任务中获取和释放这个硬件资源，然后再当前
任务中来获得该硬件资源的使用权。但是互斥信号量不一样，我们用这个互斥信号量给当前任务上锁，只有当前任务才可以解锁此互斥信号量，其他任务是不能解锁的。也就是说,
我们的硬件资源只有一个，你拿走了，只有你才能把它还回去，其他人都无法获取该资源。

互斥信号量结构体包括：一个任务事件控制块，互斥信号量上锁次数 互斥信号量的任务拥有者 互斥信号量拥有者的原始优先级

为什么需要加入一个优先级切换机制呢？

比如我们低优先级任务正在用这个mutex，然后有一个高优先级任务请求这个mutex，但是当前还有两个中优先级的任务正在运行。如果不使用优先级切换机制，那么当前这个低优先级
任务就暂时得不到执行，因为调度系统会执行中优先级的任务。那么这个高优先级任务获得此mutex锁就不可能了，当我们知道高优先级任务需要这个mutex时，把高优先级任务的
优先级赋值给低优先级的任务，加速低优先级任务的运行，当低优先级任务运行完毕释放掉这个mutex时，再把它的优先级给复原，然后高优先级任务就可以获得该mutex继续执行了。

10.2 互斥信号量的等待与通知

互斥信号量只能自己释放自己，别的任务只能等待，如果高优先级的任务在等待这个互斥信号量，那么我们就要执行优先级继承机制，加速当前任务执行。
互斥信号量只能自己通知自己然后释放互斥锁。


10.3 互斥信号量的信息获取和销毁

互斥信号的信息获取同其他模块信息获取一致，需要定义一个获取信息的结构体，然后将结构体赋值即可。
互斥信号量的销毁是判断他的锁定计数是否为0 如果大于0 则销毁事件控制块中的等待队列。


11.1 软定时器的原理和创建

我们知道一般的MCU都有硬件定时器，而且定时精度更高。那么为什么不用硬件定时器呢？因为数量不够

当我们在一些场合需要使用很多个定时器，而且定时时间要求不是很精确的时候，我们就可以使用软件定时器。

本节实现的软件定时器使用一个列表来组织的，当定时时间到的时候，就执行定时器回调函数。实现定时任务有两种实现方式：

1、专门创建一个定时任务参与系统调度，在定时任务中我们遍历定时列表，看看哪个定时列表的定时时间到了，然后执行对应定时器的回调函数。这种方式对定时器回调函数没有特别要求。
2、在周期ticks处理函数中，遍历延时列表，找到 定时时间到的任务 运行之。 这种方式要求定时器回调函数尽可能的短。

11.2 软件定时器的启动和停止

软件定时器的启动和停止其实是在操作具体的软件定时器链表，当定时时间到了的时候，执行一次回调函数即可。
注意：我们为软件定时器专门创建了一个定时任务，定时任务是通过信号量和定时周期同步的，这里可能会有延时。









